# 3. 一个 JavaScript：避免在 ECMAScript 6 中存在版本控制

### 3.1 版本控制

原则上，语言的新版本是清理它的机会，通过删除过时的功能或改变功能的工作方式。这意味着新代码在语言的旧实现中不起作用，而旧代码在新实现中不起作用。每段代码都链接到该语言的特定版本。处理不同版本的方法通常有两种。

第一种，可以采取“全有或全无”的方法，要求如果代码库要使用新版本，则必须对其进行全面升级。Python 在从 Python 2 升级到 Python 3 时采用了这种方法。它的一个问题是一次迁移所有现有代码库可能不可行，尤其是在它很大的情况下。此外，这种方法不适用于网络，因为在网络上您将始终拥有旧代码并且 JavaScript 引擎会自动更新。

第二种，可以通过使用版本标记代码来允许代码库包含多个版本的代码。Web 上，您可以通过专用的[网络 媒体类型](https://en.wikipedia.org/wiki/Media\_type)标记 ECMAScript 6 代码。

```
Content-Type: application/ecmascript;version=6
```

也可以通过 `<script>` 元素的 `type` 属性关联（默认值为 text/javascript）：

```html
<script type="application/ecmascript;version=6">
    ···
</script>
```

它指定了与实际内容之外的 out of band 版本。另一个方法可以在内容内指定（in-band）。比如：在文件中用下面这行开头：

```
use version 6;
```

两种标记方式都有问题：out-of-band 版本很脆弱并且可能会丢失，in-band版本会使代码变得混乱。

根本问题是，在代码库中允许多语言，会让一种语言变成必须并行维护的子语言。会造成一些问题：

* 引擎会变得臃肿，因为它们需要实现所有版本的语义功能。这同样适用于分析语言的工具（比如像 JSLint 这类的风格检查器）
* 程序员需要记住版本有何不同
* 代码变得更难重构，因为在移动代码片段的时候需要考虑版本。

因此，要避免版本控制，尤其对于JavaScript 和 Web。

#### 3.1.1 无版本的发展

但我们如何摆脱版本控制？通过始终向后兼容。这就意味着，谈到清理 JavaScript 的时候，需要放弃一些野心。我们不能引入重大的变化。

### 3.2 严格模式和ECMAScript 6

ECMAScript5 中引入了严格模式来清理语言。把下面这行放在文件或者函数的第一行来切换：

```
'use strict';
```

严格模式引入了三种重大的变化：

* 语法变化：一些之前合法的语法在严格模式下被禁止。比如：
  * 禁止使用 with 语句。它允许用户将任意对象添加到变量作用域中，这样会减慢执行速度并且弄清变量所指的内容变得棘手。
  * 禁止删除不合格的标志符（变量，不是属性）
  * 函数只能在作用域的顶层声明。
  * 保留了更多的标识符：implements interface let package private protected public static yield
* 更多的错误。比如：
  * 分配给未声明的变量会导致 ReferenceError。在非严格模式下，这种情况会创建一个全局变量。
  * 更改只读属性（例如字符串长度）会导致 TypeError。在非严格模式下，它根本没有作用。
* 不同语义：一些结构在严格模式下表现不同。例如：
  * arguments 不再跟踪参数的当前值。
  * this 在非方法函数中是 undefined。在非严格模式下，它指的是全局对象（window），意味着如果你不用 new 调用构造函数，就会创建全局变量。

严格模式是版本控制为何棘手的一个很好的例子：尽管它支持更简洁的 JavaScript 版本，但是它的采用率仍然相对较低。主要原因是它破坏了一些现有代码，会减慢执行速度，并且很难添加到文件中（更不用说交互式命令行了）。我喜欢严格模式的理念，但是几乎不经常用。

#### 3.2.1 支持sloppy（非严格）模式

一个JavaScript意味着我们不能放弃sloppy模式：它会继续存在（比如在HTML属性中）。因此，我们不能在严格模式之上构建 ECMAScript6，我们必须将它的特性添加到严格模式和非严格模式（又名sloppy模式）中。否则，严格模式会成为语言的不同版本，我们又回到版本控制了。不幸的是，有两个 ECMAScript 6 特性很难添加到 sloppy 模式中：let 声明和块级函数声明。我们来看看为什么会这样，以及如何添加它们。下面两条语句是合法的 ES5 sloppy 模式：

#### 3.2.2 sloppy模式中的let 声明

let 可以让你声明块级变量。sloppy 模式很难添加，因为 let 只是严格模式下的保留字。下面这两句是合法的 ES5 sloppy 代码：

```
var let = [];
let [x] = 'abc';
```

在严格的 ECMAScript 6 中，第1行会得到一个异常，因为你用保留字 let 作为变量名。第2行被解释为 let 变量声明（使用解构）。

在 sloppy ECMAScript6 中，第1行不会导致异常，但是第2行仍会被解释为let声明。这种用标识符 let 的方法在 web 太罕见了，ES6 可以承担这种解释。其他编写 let 声明的方式不会被误认为 sloppy ES5 语法。

```
let foo = 123;
let {x,y} = computeCoordinates();
```

#### 3.2.3 sloppy模式中的块级函数声明

ECMAScript5 严格模式中禁止块中的函数声明。规范允许在 sloppy 模式声明，但没有指定它们的行为方式。因此，JavaScript 的各种实现都支持，但处理它们的方式不同。

ECMAScript 6 期望块中的函数声明是该块级的本地函数。这个可以作为 ES5 严格模式的扩展，但是会破坏一些 sloppy 代码。因此，ES6 为浏览器提供了 web legacy compatibility semantic ，允许块中的函数声明存在于函数作用域中。

#### 3.2.4 其他关键词

标识符 yield 和 static 仅在 ES5 严格模式下保留。ECMAScript 6 使用特定的上下文语法规则，让它们在 sloppy 模式下运行：

* sloppy 模式中，yield 只是 generator 函数中的一个保留字。
* static 目前仅在 class 中使用，它们是隐式严格的（见下文）

#### 3.2.5 隐式严格模式

类和模块的主体在 ECMAScript 6 中隐式存在于严格模式下 - 不需要 ‘use strict’ 标记。考虑到将来几乎所有代码都将存在于模块中，ECMAScript 6 有效的将整个语言升级为严格模式。

其他结构主体（比如箭头函数和generator函数）也可以是隐式严格的。但考虑到这些结构通常很少，在 sloppy 模式下使用会造成代码在两种模式下分散。类、尤其是模块足够大，可以减少碎片问题。

#### 3.2.6 无法修复的事

One JavaScript 的缺点是你无法修复现在的 quirks，尤其是下面两个。

首先，typeof null 应该返回字符串 null 而不是 object。TC39 尝试修复它，但是它破坏了现有的代码。另一方面，为新类型的操作数添加新结果是可行的，因为目前 JavaScript 引擎已经偶尔会为宿主对象返回自定义值。一个例子是 ECMAScript 6 的 symbols：

```
> typeof Symbol.iterator
'symbol'
```

其次，全局对象（浏览器中 window）不应该在变量的作用域链中。但现在改变为时已晚。至少，在模块中，变量不会作用于全局，并且let 永远不会创建全局对象的属性，即使在全局范围用也是如此。

### 3.3 ES6 中的重大变化

ECMAScript 6 确实引入了一些小的破坏性变化（你可能不会遇到）。它们列在了两个附件中：

* [Annex D: Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact](http://www.ecma-international.org/ecma-262/6.0/#sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact)
* [Annex E: Additions and Changes That Introduce Incompatibilities with Prior Editions](http://www.ecma-international.org/ecma-262/6.0/#sec-additions-and-changes-that-introduce-incompatibilities-with-prior-editions)

### 3.4 结论

One JavaScript 意味着 ECMAScript 6 会完全向后兼容。如果能成功真是太好了。特别值得提起的是，模块（以及我们大部分代码）都隐式的处于严格模式。

短期内，在编写语言规范和引擎的实现来临之时，将 ES6 添加到严格模式和sloppy模式需要更多的工作。长远来看，规范和引擎都受益于语言没有被 forked（less bloat etc.）。程序员即时从 One JavaScript 中获益，因为这让上手 ECMAScript 6 变得更容易。

### 3.5 扩展阅读

\[1] The original 1JS proposal (warning: out of date): “[ES6 doesn’t need opt-in](http://esdiscuss.org/topic/es6-doesn-t-need-opt-in)” by David Herman.
