# 4. ES6 核心特性

本章描述了 ES6 的核心特性。这些特性很容易采用；其余特性主要看读者的兴趣了。我会通过相应的ES5代码解释每个特性。

### 4.1 从 var 到 const/let

在 ES5 中，是通过 var 来声明变量。这些变量都是函数作用域，它们的作用域是最内层的封闭函数。var 偶尔会表现的令人困惑。这儿有个例子：

```javascript
var x = 3;
function func(randomize) {
    if (randomize) {
        var x = Math.random(); // (A) scope: whole function
        return x;
    }
    return x; // accesses the x from line A
}
func(false); // undefined
```

func() 返回 undefined 可能令人惊讶。如果重写代码让它更接近反映实际发生了什么，就知道为什么了：

```javascript
var x = 3;
function func(randomize) {
    var x;
    if (randomize) {
        x = Math.random();
        return x;
    }
    return x;
}
func(false); // undefined
```

在 ES6 中，可以通过 let 和 const 额外声明变量。这些变量是块级作用域的，它们的作用域是最内部的封闭块。let 大致是 var 的块级作用于版本，但是创建的变量是无法改变的。

let 和 const 表现的更严格并会抛出更多异常（比如，在声明之前在它们作用域中去访问变量）。块级作用域有助于更局部的保持代码片段的作用范围（参见下一节演示）。并且比函数作用域更主流，这会简化 JavaScript 和其他编程语言之间的切换。

如果在最初版本将 var 替换为 let，会有不同的表现：

```javascript
let x = 3;
function func(randomize) {
    if (randomize) {
        let x = Math.random();
        return x;
    }
    return x;
}
func(false); // 3
```

这意味着不能盲目的在现在的代码中将 var 替换为 let 或者 const；在重构中需要格外小心。

我的建议是：

* 多用 const。用在那些值永远不会改变的所有变量中。
* 其次用 let - 那些值确实会改变的变量。
* 避免 var。

更多信息：[Variables and scoping](https://exploringjs.com/es6/ch\_variables.html#ch\_variables) 这一章。

### 4.2 从 IIFEs 到 代码块

在 ES5 中，如果你想把 一个变量 tmp 的作用域限制在一个块中，你得用一种称为 IIFE（Immediately-Invoked Function Expression）的模式：

```javascript
(function () {  // open IIFE
    var tmp = ···;
    ···
}());  // close IIFE

console.log(tmp); // ReferenceError
```

在 ES6 中，可以简单的用块和 let 声明（或者 const 声明）：

```javascript
{  // open block
    let tmp = ···;
    ···
}  // close block

console.log(tmp); // ReferenceError
```

更多信息：[Avoid IIFEs in ES6](https://exploringjs.com/es6/ch\_callables.html#sec\_iifes-in-es6) 这一节

### 4.3 从字符串拼接到模版语法

借助 ES6，JavaScript 最终获得了字符串插值和多行字符串。

#### 4.3.1 字符串插值

在 ES5 中，你是通过连接这些值和字符串片段把值放在字符串中：

```javascript
function printCoord(x, y) {
    console.log('('+x+', '+y+')');
}
```

在 ES6 中，可以通过模板文字实现字符串插值：

```javascript
function printCoord(x, y) {
    console.log(`(${x}, ${y})`);
}
```

#### 4.3.2 多行字符串

模板文字也有助于表示多行字符串。

比如：在 ES5 中你得这么表示一个字符串：

```javascript
var HTML5_SKELETON =
    '<!doctype html>\n' +
    '<html>\n' +
    '<head>\n' +
    '    <meta charset="UTF-8">\n' +
    '    <title></title>\n' +
    '</head>\n' +
    '<body>\n' +
    '</body>\n' +
    '</html>\n';
```

如果通过反斜杠代替换行符，可能看起来会好一点（但你仍然需要明确添加换行符）：

```javascript
var HTML5_SKELETON = '\
    <!doctype html>\n\
    <html>\n\
    <head>\n\
        <meta charset="UTF-8">\n\
        <title></title>\n\
    </head>\n\
    <body>\n\
    </body>\n\
    </html>';
```

ES6 的模板文字可以扩展多行：

```javascript
const HTML5_SKELETON = `
    <!doctype html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title></title>
    </head>
    <body>
    </body>
    </html>`;
```

(这些示例在包含多少空格方面有所不同，但无关紧要)

更多信息：[Template literals and tagged templates](https://exploringjs.com/es6/ch\_template-literals.html#ch\_template-literals) 这一章

### 4.4 从函数表达式到箭头函数

在当前 ES5 代码中，不论何时使用函数表达式都需要特别小心 this。在下面的示例中，我创建了一个辅助变量 \_this （行A），以便可以在 B 行访问 UiComponent 的 this。

```javascript
function UiComponent() {
    var _this = this; // (A)
    var button = document.getElementById('myButton');
    button.addEventListener('click', function () {
        console.log('CLICK');
        _this.handleClick(); // (B)
    });
}
UiComponent.prototype.handleClick = function () {
    ···
};
```

在 ES6 中，你可以使用箭头函数，不会隐藏 this （行A）

```javascript
function UiComponent() {
    var button = document.getElementById('myButton');
    button.addEventListener('click', () => {
        console.log('CLICK');
        this.handleClick(); // (A)
    });
}
```

（在 ES6 中，可以选择使用类而不是构造函数。稍后讨论。）

箭头函数对于那些只返回表达式结果的简短回调特别方便。

在 ES5 中，这些回调相对臃肿：

```javascript
var arr = [1, 2, 3];
var squares = arr.map(function (x) { return x * x });
```

在 ES6 中，箭头函数更加简洁：

```javascript
const arr = [1, 2, 3];
const squares = arr.map(x => x * x);
```

定义参数时，如果只有一个，甚至可以省略括号。因此：(x) => x \* x 和 x => x\* x 都是允许的。

更多信息：[Arrow functions](https://exploringjs.com/es6/ch\_arrow-functions.html#ch\_arrow-functions) 这一章

### 4.5 处理多个返回值

一些函数或方法通过数组或对象返回多个值。在 ES5 中，如果想要访问这些值，总是需要创建中间变量。在 ES6 中，通过解构可以避免中间变量。

#### 4.5.1 通过数组返回多个值

exec() 通过一个类数组对象。在 ES5 中，你需要一个中间变量（下面例子中的 matchObj），即使你只对 groups 感兴趣：

```javascript
var matchObj =
    /^(\d\d\d\d)-(\d\d)-(\d\d)$/
    .exec('2999-12-31');
var year = matchObj[1];
var month = matchObj[2];
var day = matchObj[3];
```

在 ES6 中，解构让代码更简单：

```javascript
const [, year, month, day] =
    /^(\d\d\d\d)-(\d\d)-(\d\d)$/
    .exec('2999-12-31');
```

数组开头的空插槽可以跳过索引为0的数组元素。

#### 4.5.2 通过对象返回多个值

Object.getOwnPropertyDescriptor() 方法返回一个属性描述符，是一个在其属性中包含多个值的对象。

在 ES5 中，即使你只对一个对象的属性感兴趣，仍然需要一个中间变量（下面例子的 propDesc）：

```javascript
var obj = { foo: 123 };

var propDesc = Object.getOwnPropertyDescriptor(obj, 'foo');
var writable = propDesc.writable;
var configurable = propDesc.configurable;

console.log(writable, configurable); // true true
```

在 ES6 中，你能用解构：

```javascript
const obj = { foo: 123 };

const {writable, configurable} =
    Object.getOwnPropertyDescriptor(obj, 'foo');

console.log(writable, configurable); // true true
```

`{writable, configurable}` 是 `{writable: writable, configurable: configurable}` 的缩写。

更多信息：[Destructuring](https://exploringjs.com/es6/ch\_destructuring.html#ch\_destructuring) 这一章

### 4.6 从 for 到 forEach() 到 for-of

在 ES5 之前，你可以向下面这样迭代数组：

```javascript
var arr = ['a', 'b', 'c'];
for (var i=0; i<arr.length; i++) {
    var elem = arr[i];
    console.log(elem);
}
```

在 ES5 中，可以选择使用 Array 的 `forEach()` 方法：

```javascript
arr.forEach(function (elem) {
    console.log(elem);
});
```

for 循环的优点是可以跳出，forEach() 的优点是简洁。

在 ES6 中，for-of 循环兼具了上述两个优点：

```javascript
const arr = ['a', 'b', 'c'];
for (const elem of arr) {
    console.log(elem);
}
```

如果你想要每个数组元素的索引和值，for-of 可以通过 Array 的新方法 `entries()` 和解构来满足需求：

```javascript
for (const [index, elem] of arr.entries()) {
    console.log(index+'. '+elem);
}
```

更多信息：[The `for-of` loop](https://exploringjs.com/es6/ch\_for-of.html#ch\_for-of) 这一章

### 4.7 处理参数默认值

在 ES5 中，可以像这样为参数指定默认值：

```javascript
function foo(x, y) {
    x = x || 0;
    y = y || 0;
    ···
}

```

ES6 有更好的语法：

```javascript
function foo(x=0, y=0) {
    ···
}
```

在ES6中， 一个额外的好处是，参数默认值仅由 undefined 触发，而在以前的 ES5 代码中，它由任何 falsy 值触发。

更多信息：[Parameter default values](https://exploringjs.com/es6/ch\_parameter-handling.html#sec\_parameter-default-values) 一节

### 4.8 处理命名参数

在 JavaScript 中命名参数一个常见做法是通过对象字面量（所谓的 options object pattern）：

```
selectEntries({ start: 0, end: -1 });
```

这种方法有2个优点：代码变得更具有自我描述性，并且更容易省略任意参数。

在 ES5 中，你可以按照如下方式实现 selectEntries()：

```javascript
function selectEntries(options) {
    var start = options.start || 0;
    var end = options.end || -1;
    var step = options.step || 1;
    ···
}
```

在 ES6 中，可以在参数定义中使用解构，代码会变得更简单：

```javascript
function selectEntries({ start=0, end=-1, step=1 }) {
    ···
}
```

#### 4.8.1 参数可选

在 ES5 中如果让参数 options 可选，你得把行A添加到代码中：

```javascript
function selectEntries(options) {
    options = options || {}; // (A)
    var start = options.start || 0;
    var end = options.end || -1;
    var step = options.step || 1;
    ···
}
```

在 ES6 中，你可以将 {} 指定为参数默认值：

```javascript
function selectEntries({ start=0, end=-1, step=1 } = {}) {
    ···
}
```

更多信息：[Simulating named parameters](https://exploringjs.com/es6/ch\_parameter-handling.html#sec\_named-parameters) 一节

### 4.9 从 arguments 到剩余参数

在 ES5 中，如果你想让一个函数（或方法）接受任意数量的参数，你必须用一个特殊变量 arguments：

```javascript
function logAllArguments() {
    for (var i=0; i < arguments.length; i++) {
        console.log(arguments[i]);
    }
}
```

在 ES6 中，你可以通过 ... 运算符声明一个剩余参数（下面例子中的 args）：

```javascript
function logAllArguments(...args) {
    for (const arg of args) {
        console.log(arg);
    }
}
```

如果只对跟在其后的参数感兴趣，则 rest 参数更好：

```javascript
function format(pattern, ...args) {
    ···
}
```

在 ES5 中处理这种情况略显笨拙：

```javascript
function format(pattern) {
    var args = [].slice.call(arguments, 1);
    ···
}
```

rest 参数让代码更易阅读：你可以只通过查看函数参数定义来判断该函数有可变数量的参数。

更多信息：[Rest parameters](https://exploringjs.com/es6/ch\_parameter-handling.html#sec\_rest-parameters) 一节

### 4.10 从 apply() 到展开运算符(...)

在 ES5 中，可以通过 apply() 将数组转化为参数。ES6为此有了扩展运算符。

#### 4.10.1 Math.max()

Math.max() 返回其参数中数值最大的一个。它适用于任意数量的参数，但不适用于数组。

ES5 - apply()：

```bash
> Math.max.apply(Math, [-1, 5, 11, 3])
11
```

ES6 - - 扩展运算符：

```bash
> Math.max(...[-1, 5, 11, 3])
11
```

#### 4.10.2 Array.prototype.push()

Array.prototype.push() 将其所有参数作为元素追加到 receiver 中。没有破坏数组的方法将一个数组追加到另外一个数组中。

ES5 - apply()：

```javascript
var arr1 = ['a', 'b'];
var arr2 = ['c', 'd'];

arr1.push.apply(arr1, arr2);
    // arr1 is now ['a', 'b', 'c', 'd']
```

ES6 - 展开运算符：

```javascript
const arr1 = ['a', 'b'];
const arr2 = ['c', 'd'];

arr1.push(...arr2);
    // arr1 is now ['a', 'b', 'c', 'd']
```

更多信息：[The spread operator (`...`)](https://exploringjs.com/es6/ch\_parameter-handling.html#sec\_spread-operator) 一节

### 4.11 从 concat() 到展开运算符(...)

扩展运算符还可以（非破坏性）将其操作内容转化为数组元素。这意味着它变成了 Array 方法 concat() 的替代方法。

ES5 - concat()：

```javascript
var arr1 = ['a', 'b'];
var arr2 = ['c'];
var arr3 = ['d', 'e'];

console.log(arr1.concat(arr2, arr3));
    // [ 'a', 'b', 'c', 'd', 'e' ]
```

ES6 - 扩展运算符：

```javascript
const arr1 = ['a', 'b'];
const arr2 = ['c'];
const arr3 = ['d', 'e'];

console.log([...arr1, ...arr2, ...arr3]);
    // [ 'a', 'b', 'c', 'd', 'e' ]
```

更多信息：[The spread operator (`...`)](https://exploringjs.com/es6/ch\_parameter-handling.html#sec\_spread-operator) 一节

### 4.12 从对象字面量里的函数表达式到方法定义

在 JavaScript 中，方法是值是函数的属性。

在 ES5 对象字面量中，方法的创建和其他属性类似。属性值通过函数表达式提供。

```javascript
var obj = {
    foo: function () {
        ···
    },
    bar: function () {
        this.foo();
    }, // trailing comma is legal in ES5
}
```

ES6 则是方法定义，创建方法的特殊语法：

```javascript
const obj = {
    foo() {
        ···
    },
    bar() {
        this.foo();
    },
}
```

更多信息：[Method definitions](https://exploringjs.com/es6/ch\_oop-besides-classes.html#object-literal-method-definitions) 一节

### 4.13 从构造函数到类

ES6 中的类大多只是构造函数更方便的语法。

#### 4.13.1 基类

在 ES5 中，直接实现构造函数：

```javascript
function Person(name) {
    this.name = name;
}
Person.prototype.describe = function () {
    return 'Person called '+this.name;
};
```

在 ES6 中，类为构造函数提供了稍许方便的语法：

```javascript
class Person {
    constructor(name) {
        this.name = name;
    }
    describe() {
        return 'Person called '+this.name;
    }
}
```

注意方法定义的语法 - 不需要关键字 function。另外注意各部分之间没有逗号。

#### 4.13.2 衍生类

ES5 中的子类化很复杂，尤其是涉及父类构造和父类属性。这是创建 Person 的子类 Employee 的规范方式：

```javascript
function Employee(name, title) {
    Person.call(this, name); // super(name)
    this.title = title;
}
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;
Employee.prototype.describe = function () {
    return Person.prototype.describe.call(this) // super.describe()
           + ' (' + this.title + ')';
};
```

ES6 通过 extends 子句内置了对子类化的支持：

```javascript
class Employee extends Person {
    constructor(name, title) {
        super(name);
        this.title = title;
    }
    describe() {
        return super.describe() + ' (' + this.title + ')';
    }
}
```

更多信息：[Classes](https://exploringjs.com/es6/ch\_classes.html#ch\_classes) 一章

### 4.14 从自定义错误构造函数到 Error 的子类

在 ES5 中， 异常的内置构造函数 Error 是不可能子类化的。下面代码提供了一种变通的方法，给 MyError 提供了例如堆栈追踪的重要特性：

```javascript
function MyError() {
    // Use Error as a function
    var superInstance = Error.apply(null, arguments);
    copyOwnPropertiesFrom(this, superInstance);
}
MyError.prototype = Object.create(Error.prototype);
MyError.prototype.constructor = MyError;

function copyOwnPropertiesFrom(target, source) {
    Object.getOwnPropertyNames(source)
    .forEach(function(propKey) {
        var desc = Object.getOwnPropertyDescriptor(source, propKey);
        Object.defineProperty(target, propKey, desc);
    });
    return target;
};
```

在 ES6 中，所有内置的构造函数都可以子类化，这就是为什么下面的代码实现了 ES5 只能模拟的东西：

```javascript
class MyError extends Error {
}
```

更多信息：[Subclassing built-in constructors](https://exploringjs.com/es6/ch\_classes.html#subclassing-builtin-constructors) 一章

### 4.15 从 objects 到 Maps

在 JavaScript 中，用 object 作为从字符串到任意值的映射关系（一种数据结构）一直是一种权宜之计。最安全的方法是创建一个原型为 `null` 的对象。然后你仍需要确保没有一个 key 是字符串 \`\_\_proto\_\_\`, 因为这个 key 会触发很多 JavaScript 引擎中的特殊功能。

下面是一段 ES5 代码，函数 countWords 用了一个 dict 对象作为映射：

```javascript
var dict = Object.create(null);
function countWords(word) {
    var escapedWord = escapeKey(word);
    if (escapedWord in dict) {
        dict[escapedWord]++;
    } else {
        dict[escapedWord] = 1;
    }
}
function escapeKey(key) {
    if (key.indexOf('__proto__') === 0) {
        return key+'%';
    } else {
        return key;
    }
}
```

在 ES6 中，你可以使用内置的数据结构 Map 并且不需要避开 keys。不好的是，在 Map 内部操作值的增加有些不方便。

```javascript
const map = new Map();
function countWords(word) {
    const count = map.get(word) || 0;
    map.set(word, count + 1);
}
```

Maps 的另一个好处是可以使用任意值作为 keys，不限于字符串。

更多信息：

* “Speaking JavaScript“ 的 [The dict Pattern: Objects Without Prototypes Are Better Maps](http://speakingjs.com/es5/ch17.html#dict\_pattern) 一节
* [Maps and Sets](https://exploringjs.com/es6/ch\_maps-sets.html#ch\_maps-sets) 一章

### 4.16 新的字符串方法

ECMAScript 6 的标准库为字符串提供了几种新的方法。

从 indexOf 到 startsWith：

```javascript
if (str.indexOf('x') === 0) {} // ES5
if (str.startsWith('x')) {} // ES6
```

从 indexOf 到 endsWith：

```javascript
function endsWith(str, suffix) { // ES5
  var index = str.indexOf(suffix);
  return index >= 0
    && index === str.length-suffix.length;
}
str.endsWith(suffix); // ES6
```

从 indexOf 到 includes：

```javascript
if (str.indexOf('x') >= 0) {} // ES5
if (str.includes('x')) {} // ES6
```

从 join 到 repeat（ES5 重复字符串的方法更像是一种 hack）：

```javascript
new Array(3+1).join('#') // ES5
'#'.repeat(3) // ES6
```

更多信息：[New string features](https://exploringjs.com/es6/ch\_strings.html#ch\_strings) 一章

### 4.17 新的数组方法

ES6 中还有几个新的 Array 方法。

#### 4.17.1 从 Array.prototype.indexOf 到 Array.prototype.findIndex

后者可用于查找前者无法检测到的 NaN：

```javascript
const arr = ['a', NaN];

arr.indexOf(NaN); // -1
arr.findIndex(x => Number.isNaN(x)); // 1
```

另外，新的 Number.isNaN() 提供了一种检测 NaN 的安全方式（因为它不会把非数字强制转为化数字）：

```javascript
> isNaN('abc')
true
> Number.isNaN('abc')
false
```

#### 4.17.2 从 Array.prototype.slice()  到 Array.from() 或者展开运算符

在 ES5 中，Array.prototype.slice() 用于将类数组对象转化为数组。在 ES6 中，可以用 Array.from()：

```javascript
var arr1 = Array.prototype.slice.call(arguments); // ES5
const arr2 = Array.from(arguments); // ES6
```

如果值是可迭代的（就像现在所有类似数组的 DOM 数据结构一样），也可以使用扩展运算符（...）将其转化为数组：

```javascript
const arr1 = [...'abc'];
    // ['a', 'b', 'c']
const arr2 = [...new Set().add('a').add('b')];
    // ['a', 'b']
```

#### 4.17.3 从 apply() 到 Array.prototype.fill()

在 ES5 中，可以用 apply() 作为 hack，创建人意长度的数组，并用 undefined 填充：

```javascript
// Same as Array(undefined, undefined)
var arr1 = Array.apply(null, new Array(2));
    // [undefined, undefined]
```

在 ES6 中，fill() 是一个是更简单的选择：

```javascript
const arr2 = new Array(2).fill(undefined);
    // [undefined, undefined]
```

如果你想创建一个被任意值填充的数组，fill() 会更方便：

```javascript
// ES5
var arr3 = Array.apply(null, new Array(2))
    .map(function (x) { return 'x' });
    // ['x', 'x']

// ES6
const arr4 = new Array(2).fill('x');
    // ['x', 'x']
```

fill() 用给定的值替换了所有数组元素。如果是元素，则会被视为 Holes。

更多信息：[Creating Arrays filled with values](https://exploringjs.com/es6/ch\_arrays.html#sec\_creating-filled-arrays) 一节

### 4.18 从 CommonJS 模块到 ES6 模块

即使在 ES5，不论是基于 AMD 语法或者是 CommonJs 语法的模块系统大多取代了诸如 [the revealing module pattern](http://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/) 的手写解决方案。

ES6 内置了对模块的支持。哎，目前还没JavaScript的引擎原生的支持它们。但是诸如 broserify、webpack 或者 jspm 等工具可以让你用 ES6 语法创建模块，这样写出来的代码用不过时。

#### 4.18.1 多个导出

* CommonJs 中的多个导出

在 CommonJs 中，可以用下面方式导出多个实体：

```javascript
//------ lib.js ------
var sqrt = Math.sqrt;
function square(x) {
    return x * x;
}
function diag(x, y) {
    return sqrt(square(x) + square(y));
}
module.exports = {
    sqrt: sqrt,
    square: square,
    diag: diag,
};

//------ main1.js ------
var square = require('lib').square;
var diag = require('lib').diag;

console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
```

或者，可以将整个模块作为对象导入并通过它访问 square 和 diag：

```javascript
//------ main2.js ------
var lib = require('lib');
console.log(lib.square(11)); // 121
console.log(lib.diag(4, 3)); // 5
```

* ES6 中的多个导出

在 ES6 中，多个导出被称为 exports 并会像这样：

```javascript
//------ lib.js ------
export const sqrt = Math.sqrt;
export function square(x) {
    return x * x;
}
export function diag(x, y) {
    return sqrt(square(x) + square(y));
}

//------ main1.js ------
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
```

可以像下面的语法（A 行），将模块作为对象导入：

```javascript
//------ main2.js ------
import * as lib from 'lib'; // (A)
console.log(lib.square(11)); // 121
console.log(lib.diag(4, 3)); // 5
```

#### 4.18.2 单个导出

* CommonJs 单个导出

Node.js 扩展了 CommonJs 并允许通过 module.exports 从一个模块中导出单个值：

```javascript
//------ myFunc.js ------
module.exports = function () { ··· };

//------ main1.js ------
var myFunc = require('myFunc');
myFunc();
```

* ES6 单个导出

在 ES6 中，可以通过所谓的 default export（通过 export default 声明）来实现：

```javascript
//------ myFunc.js ------
export default function () { ··· } // no semicolon!

//------ main1.js ------
import myFunc from 'myFunc';
myFunc();
```

更多信息：[Modules](https://exploringjs.com/es6/ch\_modules.html#ch\_modules) 一章

### 4.19 接下来做什么

现在你已经初尝 ES6， 可以通过浏览章节继续探索：每一章从概述开始，涵盖一个特性或一组相关功能。最后一章讲这些所有的概述部分集中在一个单独的位置。
