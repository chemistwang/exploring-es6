# 4. ES6 核心特性

本章描述了 ES6 的核心特性。这些特性很容易采用；其余特性主要看读者的兴趣了。我会通过相应的ES5代码解释每个特性。

### 4.1 从 var 到 const/let

在 ES5 中，是通过 var 来声明变量。这些变量都是函数作用域，它们的作用域是最内层的封闭函数。var 偶尔会表现的令人困惑。这儿有个例子：

```javascript
var x = 3;
function func(randomize) {
    if (randomize) {
        var x = Math.random(); // (A) scope: whole function
        return x;
    }
    return x; // accesses the x from line A
}
func(false); // undefined
```

func() 返回 undefined 可能令人惊讶。如果重写代码让它更接近反映实际发生了什么，就知道为什么了：

```javascript
var x = 3;
function func(randomize) {
    var x;
    if (randomize) {
        x = Math.random();
        return x;
    }
    return x;
}
func(false); // undefined
```

在 ES6 中，可以通过 let 和 const 额外声明变量。这些变量是块级作用域的，它们的作用域是最内部的封闭块。let 大致是 var 的块级作用于版本，但是创建的变量是无法改变的。

let 和 const 表现的更严格并会抛出更多异常（比如，在声明之前在它们作用域中去访问变量）。块级作用域有助于更局部的保持代码片段的作用范围（参见下一节演示）。并且比函数作用域更主流，这会简化 JavaScript 和其他编程语言之间的切换。

如果在最初版本将 var 替换为 let，会有不同的表现：

```javascript
let x = 3;
function func(randomize) {
    if (randomize) {
        let x = Math.random();
        return x;
    }
    return x;
}
func(false); // 3
```

这意味着不能盲目的在现在的代码中将 var 替换为 let 或者 const；在重构中需要格外小心。

我的建议是：

* 多用 const。用在那些值永远不会改变的所有变量中。
* 其次用 let - 那些值确实会改变的变量。
* 避免 var。

更多信息：[Variables and scoping](https://exploringjs.com/es6/ch\_variables.html#ch\_variables) 这一章。

### 4.2 从 IIFEs 到 代码块

在 ES5 中，如果你想把 一个变量 tmp 的作用域限制在一个块中，你得用一种称为 IIFE（Immediately-Invoked Function Expression）的模式：

```javascript
(function () {  // open IIFE
    var tmp = ···;
    ···
}());  // close IIFE

console.log(tmp); // ReferenceError
```

在 ES6 中，可以简单的用块和 let 声明（或者 const 声明）：

```javascript
{  // open block
    let tmp = ···;
    ···
}  // close block

console.log(tmp); // ReferenceError
```

更多信息：[Avoid IIFEs in ES6](https://exploringjs.com/es6/ch\_callables.html#sec\_iifes-in-es6) 这一节

### 4.3 从字符串拼接到模版语法

借助 ES6，JavaScript 最终获得了字符串插值和多行字符串。

#### 4.3.1 字符串插值

在 ES5 中，你是通过连接这些值和字符串片段把值放在字符串中：

```javascript
function printCoord(x, y) {
    console.log('('+x+', '+y+')');
}
```

在 ES6 中，可以通过模板文字实现字符串插值：

```javascript
function printCoord(x, y) {
    console.log(`(${x}, ${y})`);
}
```

#### 4.3.2 多行字符串

模板文字也有助于表示多行字符串。

比如：在 ES5 中你得这么表示一个字符串：

```javascript
var HTML5_SKELETON =
    '<!doctype html>\n' +
    '<html>\n' +
    '<head>\n' +
    '    <meta charset="UTF-8">\n' +
    '    <title></title>\n' +
    '</head>\n' +
    '<body>\n' +
    '</body>\n' +
    '</html>\n';
```

如果通过反斜杠代替换行符，可能看起来会好一点（但你仍然需要明确添加换行符）：

```javascript
var HTML5_SKELETON = '\
    <!doctype html>\n\
    <html>\n\
    <head>\n\
        <meta charset="UTF-8">\n\
        <title></title>\n\
    </head>\n\
    <body>\n\
    </body>\n\
    </html>';
```

ES6 的模板文字可以扩展多行：

```javascript
const HTML5_SKELETON = `
    <!doctype html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title></title>
    </head>
    <body>
    </body>
    </html>`;
```

(这些示例在包含多少空格方面有所不同，但无关紧要)

更多信息：[Template literals and tagged templates](https://exploringjs.com/es6/ch\_template-literals.html#ch\_template-literals) 这一章

### 4.4 从函数表达式到箭头函数

在当前 ES5 代码中，不论何时使用函数表达式都需要特别小心 this。在下面的示例中，我创建了一个辅助变量 \_this （行A），以便可以在 B 行访问 UiComponent 的 this。

```javascript
function UiComponent() {
    var _this = this; // (A)
    var button = document.getElementById('myButton');
    button.addEventListener('click', function () {
        console.log('CLICK');
        _this.handleClick(); // (B)
    });
}
UiComponent.prototype.handleClick = function () {
    ···
};
```

在 ES6 中，你可以使用箭头函数，不会隐藏 this （行A）

```javascript
function UiComponent() {
    var button = document.getElementById('myButton');
    button.addEventListener('click', () => {
        console.log('CLICK');
        this.handleClick(); // (A)
    });
}
```

（在 ES6 中，可以选择使用类而不是构造函数。稍后讨论。）

箭头函数对于那些只返回表达式结果的简短回调特别方便。

在 ES5 中，这些回调相对臃肿：

```javascript
var arr = [1, 2, 3];
var squares = arr.map(function (x) { return x * x });
```

在 ES6 中，箭头函数更加简洁：

```javascript
const arr = [1, 2, 3];
const squares = arr.map(x => x * x);
```

定义参数时，如果只有一个，甚至可以省略括号。因此：(x) => x \* x 和 x => x\* x 都是允许的。

更多信息：[Arrow functions](https://exploringjs.com/es6/ch\_arrow-functions.html#ch\_arrow-functions) 这一章

### 4.5 处理多个返回值

一些函数或方法通过数组或对象返回多个值。在 ES5 中，如果想要访问这些值，总是需要创建中间变量。在 ES6 中，通过解构可以避免中间变量。

#### 4.5.1 通过数组返回多个值

exec() 通过一个类数组对象。在 ES5 中，你需要一个中间变量（下面例子中的 matchObj），即使你只对 groups 感兴趣：

```javascript
var matchObj =
    /^(\d\d\d\d)-(\d\d)-(\d\d)$/
    .exec('2999-12-31');
var year = matchObj[1];
var month = matchObj[2];
var day = matchObj[3];
```

在 ES6 中，解构让代码更简单：

```javascript
const [, year, month, day] =
    /^(\d\d\d\d)-(\d\d)-(\d\d)$/
    .exec('2999-12-31');
```

数组开头的空插槽可以跳过索引为0的数组元素。

#### 4.5.2 通过对象返回多个值

Object.getOwnPropertyDescriptor() 方法返回一个属性描述符，是一个在其属性中包含多个值的对象。

在 ES5 中，即使你只对一个对象的属性感兴趣，仍然需要一个中间变量（下面例子的 propDesc）：

```javascript
var obj = { foo: 123 };

var propDesc = Object.getOwnPropertyDescriptor(obj, 'foo');
var writable = propDesc.writable;
var configurable = propDesc.configurable;

console.log(writable, configurable); // true true
```



### 4.6 从 for 到 forEach() 到 for-of

### 4.7 处理参数默认值

### 4.8 处理命名参数

### 4.9 从 arguments 到剩余参数

### 4.10 从 apply() 到展开运算符(...)

### 4.11 从 concat() 到展开运算符(...)

### 4.12 从对象字面量函数表达式到方法定义

### 4.13 从构造函数到类

### 4.14 从自定义错误构造函数到 Error 的子类

### 4.15 从 objects 到 Maps

### 4.16 新的字符串方法

### 4.17 新的数组方法

### 4.18 从 CommonJS 模块到 ES6 模块

### 4.19 接下来做什么
